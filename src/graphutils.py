"""
@file graphutils.py
@brief A module to work with call graphs in a JavaScript file.

This module provides a way to generate call graphs in the form of a DOT file,
from a JavaScript file. The call graph generated from this file is incomplete,
which means that this module cannot infer calls made by an alias. For example,
this will not be detected:

    var a = chrome;
    a.extension.getURL();

Ivan Gozali <gozaliivan@berkeley.edu>

"""
import fileutils
import alpharenamer
import astutils
import pynarcissus.jsparser
import pynarcissus.sexp

import os
import argparse

from ucb import main

from pygraph.classes.digraph import digraph
from pygraph.readwrite.dot import write

def generate_nodes_edges(frame):
    """Receives a frame object generated by the create_frame() function in
    alpharenamer.py, and generates the nodes and edges for the call graph.

    frame - an alpharenamer.Frame object created by applying the function
            create_frame() on an ast object.
    """
    node_list = []
    
    def generate_node_helper(frame):
        node_list.append(frame.name)
    alpharenamer.traverse_frames(frame, generate_node_helper)

    call_tuple_list = []
    
    def generate_edges_helper(frame):
        for call in frame.callList:
            if call.name not in node_list:
                node_list.append(call.name)
            call_tuple = (frame.name, call.name)
            call_tuple_list.append(call_tuple)
    alpharenamer.traverse_frames(frame, generate_edges_helper)
    
    return (node_list, call_tuple_list)

def create_call_graph(node_list, edge_list):
    """Creates the pygraph graph object that represents the call graph of the
    JavaScript module.
    
    node_list - list of nodes which represent functions
    edge_list - list of edges which represent functions calling other functions
    """
    call_graph = digraph()
    
    call_graph.add_nodes(node_list)
    
    for edge in edge_list:
        call_graph.add_edge(edge)
    
    return call_graph

def isunknown(name):
    return name.endswith("?")

def clean_call_list(frame):
    """Removes calls that are unknown. """
    for call in frame.callList[:]:
        if isunknown(call.name):
            frame.callList.remove(call)

def count_lambda(frame):
    """Counts the number of anonymous functions in the JavaScript code."""
    count = [0]
    def count_lambda_helper(frame):
        if frame.islambda:
            count[0] += 1
    alpharenamer.traverse_frames(frame, count_lambda_helper)
    return count[0]

def count_chrome_reference(frame):
    count = [0]
    def count_chrome_reference_helper(frame):
        if frame.calls_chrome:
            count[0] += 1
    alpharenamer.traverse_frames(frame, count_chrome_reference_helper)
    return count[0]

@main
def run(*args):
    parser = argparse.ArgumentParser(prog="graphutils.py", 
            description="Generates incomplete call graphs from JavaScript files.")
    
    parser.add_argument("filepath", action="store", 
            help="the path to JavaScript file or a Chrome extension itself")

    parser.add_argument("-o", action="store", dest="outputpath", 
            help="""output path (not the file!). the output file name will be the
            same as the extension or original JS file name.""")

    parser.add_argument("-e", action="store_true", 
            default=False, dest="isextension", 
            help="""indicates that filepath is a path to a single extension
            (e.g. extensions/aapbdbdomjkkjkaonfhkkikfgjllcleb)""")
    
    results = parser.parse_args()

    filepath = results.filepath
    if results.outputpath:
        outputpath = results.outputpath
        if not os.path.exists(outputpath):
            os.mkdir(outputpath)
    else:
        outputpath = "." # current directory

    isextension = results.isextension
    if isextension:
        ext_path = filepath
        ext = os.path.basename(filepath)
        outputname = ext

        try:
            ext_name = fileutils.get_extension_name(os.path.join(ext_path, ext))
            if ext_name is None:
                raise Exception()
        except:
            ext_name = "Unknown"
        print(ext_name)
    
        print "Combining extension .js files...",
        js_string = fileutils.combine_js_files(os.path.join(ext_path, ext))
        print "OK"
    else:
        # Take the filename without extension
        outputname = os.path.splitext(os.path.basename(filepath))[0]
        
        print "Reading JS file...",
        js_file = open(filepath, "r")
        js_string = js_file.read()
        js_file.close()
        print "OK"

    # ------------------- SETUP PHASE -------------------
    # --- Open and Create AST from Extension ---
    print "Creating AST...",
    ast = astutils.create_AST_from_string(js_string)
    print "OK"
    
    # --- Create Frame object and execute alpha-rename ---
    print "Creating frames...",
    fr = alpharenamer.create_frames(ast)
    print "OK"
    
    print "Alpha-renaming...",
    fr = alpharenamer.alpha_rename(fr, ast)
    print "OK"

    # --- Clean Call List ---
    print "Cleaning call list of frames...",
    alpharenamer.traverse_frames(fr, clean_call_list)
    print "OK"

    # ------------------- OUTPUT PHASE -------------------
    # --- Create Call Graph in DOT Format ---
    print "Writing DOT file... ",
    # node_list : list of all the function calls in the source
    # edge_list : list of tuples denoting edges between calls
    node_list, edge_list = generate_nodes_edges(fr)

    call_gr = create_call_graph(node_list, edge_list)

    dot_file = open(os.path.join(outputpath, outputname + "_dot.txt"), "w")
    dot = write(call_gr)
    dot_file.write(dot)
    print "OK"
    
    # --- Create Separate Chrome API Calls ---
    # TODO: Might want to move this to another module
    #print "Writing Unique Chrome API Calls...",
    #chromecalls_file = dot_file = open(out_path + "\\" + ext + "_chromecalls.txt", "w")
    #chrome_call_str = ""
    #for chromecall in node_list:
    #    if "chrome" in chromecall and chromecall not in chrome_call_str:
    #        chrome_call_str += chromecall + "\n"
    #chromecalls_file.write(chrome_call_str)
    #print "OK"
    
    # --- Write AST representation to file ---
    #ast_out = open("ast_out_newTest2.txt", "w")
    #ast_out.write(str(ast))
    
    # --- Generate log file ---
    # TODO: Might want to move this to another module
    #print "Generating log file..."
    #log_string = ""
    #log_string += "Extension Name: " + ext_name + "\n"
    #log_string += "Extension Identifier: " + ext + "\n"
    #
    #fn_count = fr.new_id
    #lambda_count = count_lambda(fr)
    #chrome_count = count_chrome_reference(fr)
    #log_string += "Number of functions: " + str(fn_count) + "\n"
    #log_string += "Number of anonymous functions: " + str(lambda_count) + "\n"
    #log_string += "Number of named functions: " + str(fn_count - lambda_count) + "\n"
    #log_string += "Number of functions that reference chrome: " + str(chrome_count) + "\n"
    #
    #print(log_string)
    #log_file = open(out_path + "\\" + ext + "_log.txt", "w")
    #log_file.write(log_string)
    #print "Generation of log file OK"
    #print "Program successfully completed"
