# Written in Python 2

import jsparser
import os
import sys
import inspect

# def parse(source, filename=None, starting_line_number=1)

# -------------- Other Utility Functions -----------------------

# Credits to John DeNero, CS61A Fall 2011 Instructor @ UC Berkeley
def main(fn):
    """Call fn with command line arguments.  Used as a decorator.

    The main decorator marks the function that starts a program. For example,
    
    @main
    def my_run_function():
        # function body
    
    Use this instead of the typical __name__ == "__main__" predicate.
    """
    if inspect.stack()[1][0].f_locals['__name__'] == '__main__':
        args = sys.argv[1:] # Discard the script name from command line
        fn(*args) # Call the main function

# -------------- Functions to work with files -------------------

def get_directory_tree(dir):
    """
    Returns a generator object containing the directory tree. 
    
    A directory tree is a sequence of 3-tuples, where each 3-tuple contains:
    - dirpath:   the absolute directory path of all the directories and 
                 subdirectories in dir
    - dirnames:  a list of relative subdirectories in the current dirpath
    - filenames: a list of relative filenames in the current dirpath
    
    dir - absolute directory path from which the directory tree object
          is to be obtained
    """
    
    return os.walk(dir)

def get_current_directory_tree():
    """
    Returns a generator object containing the current directory tree.
    
    A directory tree is a sequence of 3-tuples, where each 3-tuple contains:
    - dirpath:   the absolute directory path of all the directories and 
                 subdirectories in dir
    - dirnames:  a list of relative subdirectories in the current dirpath
    - filenames: a list of relative filenames in the current dirpath
    """
    return get_directory_tree(os.getcwd())

def print_directory_tree(dir_tree):
    """
    Prints a visual representation of the directory tree object returned
    by get_directory_tree (i.e. returned by os.walk()).
    
    dir_tree - generator object containing the directory tree
    """
    # NOT IMPLEMENTED YET
    return None

def is_file_type(filename, extension):
    """
    Checks whether a file is of a certain file type (by checking its
    extension). For example, to check whether file is JavaScript, 
    pass in the filename and extension will be ".js". Returns True/False.
    
    filename - the absolute/relative path to the file
    extension - a string specifying the extension of the file
    """
    file = str(filename)
    if extension == file[len(file)-len(extension):]:
        return True
    else:
        return False

def is_javascript_file(filename):
    return is_file_type(filename, ".js")

def get_chrome_extensions_path():
    chrome_path = "C:\Users\\" + os.getenv("USERNAME") + "\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions"
    
    if os.path.exists(chrome_path):
        return chrome_path
    else:
        return "Directory does not exist."
    
def print_all_javascript_files_in_current_directory():
    dir_tree = get_current_directory_tree()
    
    for dirpath, dirnames, filenames in dir_tree:
        print("Current directory: {0}".format(dirpath))
        for i, file in enumerate(filenames):
            if is_javascript_file(file):
                print("File {0} : {1}".format(i, file))
        print("------------------------------------")

def get_all_javascript_files_absolute(dir):
    """
    Returns a list of absolute paths to JavaScript files.
    
    dir - absolute path to the directory to be analyzed
    """
    
    dir_tree = get_directory_tree(dir)
    js_list = []
    
    for dirpath, dirnames, filenames in dir_tree:
        for file in filenames:
            if is_javascript_file(file):
                js_list.append(str(os.path.join(dirpath, file)))
    
    return js_list
    
# -------------- Utilities to work with pynarcissus' Abstract Syntax Tree --------------------

class FunctionContainer(object):
    def __init__(self, name, node):
        self.name = name
        self.node = node
    
    @property
    def call_list(self):
        return get_calls_in_function(self.node)
    
    def __str__(self):
        string = ""
        string += "Function " + self.name + "\n"
        for call in self.call_list:
            string += "---- " + call.getSource() + " at line " + str(call.lineno) + "\n"
        return string
    

def get_all_functions_in_global(ast):
    """
    Return a list of AST nodes which are of type function only in 
    the global frame of js file.
    
    ast - the AST generated by pynarcissus' parse() function
    """
    # If ast is in global, then this ast will be of type "SCRIPT"
    # and will contain funDecls attribute.
    functions = []
    for function in ast.funDecls:
        functions.append(FunctionContainer(function.name, function))
    return functions

def create_AST(js_path):
    """
    Returns the AST corresponding to the JavaScript file specified as js_path.
    js_path can be relative or absolute.
    """
    
    if os.path.exists(js_path):
        if os.path.isabs(js_path):
            js_file = os.path.split(js_path)[1]
        else:
            js_file = js_path
    else:
        return "File does not exist."
    
    if is_javascript_file(js_file):
        return jsparser.parse(open(js_path, "r").read(), js_file)
    
# traverse_AST done. Need to check for missed nodes, though.
def traverse_AST(node, fn):
    fn(node)
    
    # If the current node does not have a list, it might contain a 
    # body or expression attribute. Try to look for them first.
    if len(node) == 0:
        for key in node.__dict__.keys():
            attr = getattr(node, str(key))
                
            if type(attr) == jsparser.Node:
                traverse_AST(attr, fn)
    
    # If the current node has a list, then the elements of the list
    # will be of type jsparser.Node. Traverse all of them.
    if len(node) != 0:
        for elem in node:
            traverse_AST(elem, fn)
            
def get_calls_in_function(fn_node):
    def is_call_node(node):
        if getattr(node, 'type', None) is not None:
            if node.type == 'CALL':
                return True
        return False
        
    call_list = []
    def append_call_node(node):
        if is_call_node(node):
#           print(type(node))
            call_list.append(node)
            
    traverse_AST(fn_node, append_call_node)
    return call_list
        
@main
def begin(*args):
#    chrome_path = get_chrome_extensions_path()
#    extension_path = os.path.join(testpath, "gighmmpiobklfepjocnamgkkbiglidom")
    
    # js_list contains all the javascript files in absolute paths
#    js_list = get_all_javascript_files_absolute(testdir)
#    for jsf in js_list:
#        print(jsf)
    
    test_path = "C:\\Users\\Ivan Gozali\\Desktop\\ExtensionAnalyzer\\javascripts\\adblock.js"
    ast = create_AST(test_path)

    fn_list = get_all_functions_in_global(ast)
    # print("--------------------------------")
    # print(ast)
    # print("--------------------------------")
    # print(len(fn_list))
    
    for f in fn_list:
        print(f)
    
    #res = get_calls_in_function(fn_list[0])
#    print(res[0])
    #for r in res:
    #    print(r.getSource() + " at line " + str(r.lineno))      
        
    