# Written in Python 2
# Ivan Gozali

import pynarcissus.jsparser
from ucb import main
from fileutils import *

DEBUGGING = True

# -------------- Other Utility Functions -----------------------

def debugprint(str=""):
    global DEBUGGING
    if DEBUGGING:
        print(str)

# -------------- Utilities to work with pynarcissus' Abstract Syntax Tree --------------------

class FunctionContainer(object):
    """
    This class is a container for the AST nodes whose type is FUNCTION.
    FunctionContainers have two important properties:
        1. They contain the function name
        2. They have, as a property, a list that contains all the call
           statements in the function.
    
    When an instance of a FunctionContainer is printed, it will print the 
    name and all the calls to Chrome API.
    """
    def __init__(self, name, node):
        self.name = name
        self.node = node
        self.call_list = self.get_call_statements(self.node)
        self.chrome_call_list = self.get_chrome_call_list()
    
    def get_call_statements(self, node):
        def is_call_node(node):
            if getattr(node, 'type', None) == 'CALL':
                return True
            return False
            
        call_list = []
        
        def append_call_node(node):
            if is_call_node(node):
                call_list.append(node)
                
        traverse_AST(node, append_call_node)
        return call_list

    def get_chrome_call_list(self):
        chrome_calls = []
        for call in self.call_list:
            if "chrome" == call.getSource()[0:6]:
                chrome_calls.append(call)
        return chrome_calls
    
    def __str__(self):
        string = ""
        string += "Function " + self.name + "\n"
        if len(self.chrome_call_list) == 0:
            string += "---- No calls to Chrome API found in this function \n"
            return string
        for call in self.chrome_call_list:
            string += "---- " + call.getSource() + " at line " + str(call.lineno) + "\n"
        return string
    
class GlobalContainer(object):
    def __init__(self, node):
        self.node = node
        self.call_list = self.get_call_list()
        self.chrome_call_list = self.get_chrome_call_list()
    
    def get_elem_list(self):
        elements = []
        for elem in self.node:
            if elem.type != "FUNCTION":
                elements.append(elem)
        return elements
    
    def get_call_statements(self, node):
        def is_call_node(node):
            if getattr(node, 'type', None) == 'CALL':
                return True
            return False
            
        call_list = []
        
        def append_call_node(node):
            if is_call_node(node):
                call_list.append(node)
                
        traverse_AST(node, append_call_node)
        return call_list
    
    def get_call_list(self):
        calls = []
        for elem in self.get_elem_list():
            calls.extend(self.get_call_statements(elem))
        return calls

    def get_chrome_call_list(self):
        chrome_calls = []
        for call in self.get_call_list():
            if "chrome" == call.getSource()[0:6]:
                chrome_calls.append(call)
        return chrome_calls
    
    def __str__(self):
        string = ""
        string += "Global Frame \n"
        if len(self.chrome_call_list) == 0:
            string += "---- No calls to Chrome API found in the global frame \n"
            return string
        for call in self.chrome_call_list:
            string += "---- " + call.getSource() + " at line " + str(call.lineno) + "\n"
        return string
    
        
def get_all_functions_in_global(ast):
    """
    Return a list of FunctionContainers nodes which are in 
    the global frame of js file.
    
    ast - the AST generated by pynarcissus' parse() function
    """
    # If ast is in global, then this ast will be of type "SCRIPT"
    # and will contain funDecls attribute.
    functions = []
    for function in ast.funDecls:
        functions.append(FunctionContainer(function.name, function))
    return functions

def create_AST(js_path):
    """
    Returns the AST corresponding to the JavaScript file specified as js_path.
    js_path can be relative or absolute.
    """
    
    if os.path.exists(js_path):
        js_file = convert_abs_to_rel(js_path)
    else:
        return "File does not exist."
    
    if is_javascript_file(js_file):
        return pynarcissus.jsparser.parse(open(js_path, "r").read(), js_file)
    
# traverse_AST done. Need to check for missed nodes, though.
def traverse_AST(node, fn):
    """
    Traverses the whole AST passed in as node, and applies the function fn
    to each node.
    
    This function WILL NOT TRAVERSE THE varDecls attribute of the AST, because
    the varDecls attribute is of type list, and as such does not get included.
    
    If we call count_nodes on the AST, the result will be the number of nodes 
    in the AST minus the number of nodes in the AST's varDecl.
    
    node - The head node of the AST
    fn   - A function that will be applied to every node in the AST.
    """
    fn(node)
    
    # If the current node has a list, then the elements of the list
    # will be of type jsparser.Node. Traverse all of them.
    if len(node) != 0:
        for elem in node:
            traverse_AST(elem, fn)
    
    # Regardless of whether it has a list, it might contain a 
    # body or expression attribute. Try to look for them also.
    for key in node.__dict__.keys():
        attr = getattr(node, str(key))

        # Special handling for looping statements, otherwise it 
        # will recurse infinitely (especially the CONTINUE statement)
        if key == "target":
            continue
        
        if type(attr) == pynarcissus.jsparser.Node:
            traverse_AST(attr, fn)

def get_node_count(ast):
    count = {'val':0}
    def count_nodes(node):
        count['val'] += 1
    traverse_AST(ast, count_nodes)
    return count['val']

def analyze_single(filename):
    result = ""
    
    # ast is the whole JavaScript file.
    try:
        ast = create_AST(filename)
    except Exception, e:
        result += "Error occurred while parsing file \"" + filename + "\"\n\n"
        return result, 0
    
    chrome_call_count = 0
    
    result += "JavaScript file: {0}\n".format(convert_abs_to_rel(filename)) 
    
    glob = GlobalContainer(ast)
    result += str(glob)
    chrome_call_count += len(glob.chrome_call_list)
    
    fn_list = get_all_functions_in_global(ast)
    for f in fn_list:
        result += str(f)
        chrome_call_count += len(f.chrome_call_list)
    
    result += "\n"
    return result, chrome_call_count

def analyze_directory(directory):
    result = ""
    
    js_list = get_all_javascript_files_absolute(directory)
    
    result += "Current directory: {0}\n".format(directory)
    chrome_call_count = 0
    
    for js in js_list:
        temp_result, temp_chrome = analyze_single(js)
        result += temp_result
        chrome_call_count += temp_chrome
    
    return result, chrome_call_count

def analyze_statistics(filename):
    """
    Analyze statistics of a JavaScript file. Returns a tuple containing 
    the number of functions that reference the Chrome API and the total
    number of functions in the module.
    
    Global counts as 1 function/module. If global contains multiple calls
    to Chrome API, it counts as 1 contain_chrome_call.
    """
    
    def contains_chrome_call(container):
        if len(container.chrome_call_list) != 0:
            return True
        return False
    
    try:
        ast = create_AST(filename)
    except Exception, e:
        raise e
    contains_chrome_calls = 0
    total_fn = 0
    
    glob = GlobalContainer(ast)
    total_fn += 1
    if contains_chrome_call(glob):
        contains_chrome_calls += 1
    
    fn_list = get_all_functions_in_global(ast)
    total_fn += len(fn_list)
    
    for fn in fn_list:
        if contains_chrome_call(fn):
            contains_chrome_calls += 1
    
    return contains_chrome_calls, total_fn

def analyze_statistics_directory(directory):
    result = ""
    
    js_list = get_all_javascript_files_absolute(directory)
    contains_chrome_calls = 0
    total_fn = 0
    
    debugprint("Current directory: {0}\n".format(directory))
    result += "Current directory: {0}\n".format(directory)
    
    for js in js_list:
        temp_chrome, temp_total = analyze_statistics(js)
        contains_chrome_calls += temp_chrome
        total_fn += temp_total
    
    debugprint("Total functions/modules (including global): {0}\n".format(total_fn))
    result += "Total functions/modules (including global): {0}\n".format(total_fn)
    debugprint("Total functions/modules that reference Chrome: {0}\n".format(contains_chrome_calls))
    result += "Total functions/modules that reference Chrome: {0}\n".format(contains_chrome_calls)
    result += "\n"
    return result

def analyze_statistics_extensions_directory(directory):
    result = ""
    
    ext_dir_list = get_chrome_extensions_path_list(directory)
    
    for ext_dir in ext_dir_list:
        result += analyze_statistics_directory(ext_dir)
    
    return result
    
    

@main
def begin(*args):
    help = """
    Launches the analyzer with the following command-line arguments.
    
    Syntax
    python analyzer.py -s filename|-a directory|-c|-t directory [-o output]
        
    Usage:
    - s   filename   Analyzes a single file
    - a   directory  Analyzes all the JavaScript files found in that directory
    - c              Attempts to find the Chrome extensions folder and analyzes
                     all the extensions found inside.
    - t   directory  Analyzes the statistics of an extension directory.
    - tt  directory  Analyzes the statistics of an Extensions folder. An 
                     Extensions folder is the folder that contains the 
                     32-character long folders containing extensions.
    - o   out_file   Writes the result to an output file specified as out_file
    
    """

#    check = [arg for arg in args if arg not in ['-s', '-a', '-c', '-o']]
#    if len(check) > 0:
#        print("Invalid arguments exist.")
#        exit()

    # Test Path Test Case
#    test_path = "C:\\PythonProjects\\ExtensionAnalyzer\\src\\test.js"    
#    ast = create_AST(test_path)
#    print("Count: {0}".format(get_node_count(ast)))
#    f = open("output.txt", "w")
#    f.write(str(ast))

    
    choice = [arg for arg in args if arg in ['-s', '-a', '-c']]
    if len(choice) > 1:
        print("Too many required arguments specified")
        exit()
    
    if '-h' in args:
        print(help)
        exit()
    
    if '-s' in args:
        file = args[args.index('-s') + 1]
        result, total = analyze_single(file)
    elif '-a' in args:
        directory = args[args.index('-a') + 1]
        result, total = analyze_directory(directory)
    elif '-c' in args:
        directory = get_chrome_extensions_path()
        result, total = analyze_directory(directory)
    elif '-t' in args:
        directory = args[args.index('-t') + 1]
        result = analyze_statistics_directory(directory)
    elif '-tt' in args:
        directory = args[args.index('-tt') + 1]
        result = analyze_statistics_extensions_directory(directory)
    

    if '-o' in args:
        out_file = args[args.index('-o') + 1]
        f = open(out_file, "w")
        f.write(result)
    else:
        print(result) 

#    chrome_path = get_chrome_extensions_path()
#    extension_path = os.path.join(chrome_path, "gighmmpiobklfepjocnamgkkbiglidom")
#    extension_path = '/home/devdatta/.config/chromium/Default/Extensions/gighmmpiobklfepjocnamgkkbiglidom'
#    js_list = get_all_javascript_files_absolute(extension_path)
#    
#    total = 0
#    
#    print("Current extension directory: {0}".format(extension_path))
#    for js in js_list:
#        ast = create_AST(js)
#        print("JavaScript file: {0}".format(os.path.split(js)[1]))
#        
#        # Print information about the global frame
#        glob = GlobalContainer(ast)
#        print(glob)
#        total += len(glob.chrome_call_list)
#        
#        # Print information about all functions
#        fn_list = get_all_functions_in_global(ast)
#        for f in fn_list:
#            print(f)
#            total += len(f.chrome_call_list)
#    
#    print("Total Chrome calls found: " + str(total))

