How to Use graphutils.py

This document briefly describes how to use graphutils.py, which allows
generation of call graphs from a JavaScript file. 

The input of graphutils.py is a JavaScript file. The output of graphutils.py is
a DOT file containing the incomplete call graph of the JavaScript file.

--- Steps ---

Using graphutils is quite easy. The following example illustrates how to use the
module:

    python graphutils.py example.js

where example.js is the JavaScript file you want to generate the call graph
from. This will generate the call graph in the current directory.

If you want to specify the output directory of this module, simply use the -o
option:

    python graphutils.py -o graph_output example.js

This will create the call graph file at the graph_output directory, which has to
be located in the current directory.

--- Example of Generated Call Graph --- 

The following is an example of the generated call graph. Consider the following 
JavaScript file:

    // example.js
    function foo() {
        var baz = bar();
        return baz;
    }

    function bar() {
        return 10;
    }

    function foobar() {
        var a = foo();
        var b = bar();
        return a + b;
    }

After running the graphutils.py module on this file, this is the generated call
graph:

    // example_dot.txt
    digraph graphname {
    foo_R_1;
    global_R_0;
    foobar_R_3;
    bar_R_2;
    foo_R_1 -> bar_R_2;
    foobar_R_3 -> foo_R_1;
    foobar_R_3 -> bar_R_2;
    }

As you can see, there are 4 nodes in the call graph, and three edges. 

The "_R_#" is simply an identifier which is appended by the program to
differentiate functions in different scopes. 

You can see 3 nodes that are immediately obvious in what they represent. "foo",
"bar" and "foobar" are functions declared in the global scope. But you can also
see a keyword called "global", which is automatically generated by the program
and represents the global scope.

We can also see that the function foo() calls bar(), and the function foobar()
calls foo() and bar(), hence the edges from foo -> bar, foobar -> foo and foobar
-> bar. 

